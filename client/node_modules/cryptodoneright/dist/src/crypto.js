"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var promised_callback_1 = __importDefault(require("promised-callback"));
var protobufjs_1 = __importDefault(require("protobufjs"));
var through2_1 = __importDefault(require("through2"));
var datas = __importStar(require("./tasks/data"));
var hashes = __importStar(require("./tasks/hash"));
var keys = __importStar(require("./tasks/keys"));
var passwords_1 = __importDefault(require("./tasks/passwords"));
var random = __importStar(require("./tasks/random"));
var signverify = __importStar(require("./tasks/sign_verify"));
function secure_password(unsecured_password, callback) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var _a, done, error, secured_password, is_secure_password;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = promised_callback_1["default"](resolve, reject, callback), done = _a.done, error = _a.error;
                                    return [4, passwords_1["default"].hash(unsecured_password)];
                                case 1:
                                    secured_password = _b.sent();
                                    return [4, passwords_1["default"].verify(unsecured_password, secured_password)];
                                case 2:
                                    is_secure_password = _b.sent();
                                    if (is_secure_password) {
                                        done(secured_password);
                                    }
                                    else {
                                        error("FAILURE_TO_VERIFY_HASH_CREATION");
                                    }
                                    return [2];
                            }
                        });
                    }); })];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.secure_password = secure_password;
function verify_password(input_password_str, secured_password_hex, callback) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var _a, done, error, result, err_1;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = promised_callback_1["default"](resolve, reject, callback), done = _a.done, error = _a.error;
                                    _b.label = 1;
                                case 1:
                                    _b.trys.push([1, 3, , 4]);
                                    return [4, passwords_1["default"].verify(input_password_str, secured_password_hex)];
                                case 2:
                                    result = _b.sent();
                                    done(result);
                                    return [3, 4];
                                case 3:
                                    err_1 = _b.sent();
                                    error({ error: "PASSWORD_VERIFYING_FAIL", meta: { input_password_str: input_password_str, secured_password_hex: secured_password_hex } });
                                    return [3, 4];
                                case 4: return [2];
                            }
                        });
                    }); })];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.verify_password = verify_password;
var encrypted_data_proto = new protobufjs_1["default"].Type("encrypted")
    .add(new protobufjs_1["default"].Field("type", 1, "string"))
    .add(new protobufjs_1["default"].Field("data", 2, "bytes"));
var proto_root = new protobufjs_1["default"].Root().define("data").add(encrypted_data_proto);
var encrypted_data_schema = proto_root.lookupType("data.encrypted");
exports.hash = hashes.hash;
function encrypt_data(data, callback) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var _a, done, error, type, encrypted_data_container, serialized_data, encrypted_data;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = promised_callback_1["default"](resolve, reject, callback), done = _a.done, error = _a.error;
                                    return [4, get_data_type(data)["catch"](error)];
                                case 1:
                                    type = _b.sent();
                                    if (type !== "bytes") {
                                        if (type === "message") {
                                            data = Buffer.from(JSON.stringify(data));
                                        }
                                        else {
                                            data = Buffer.from(data.toString());
                                        }
                                    }
                                    encrypted_data_container = encrypted_data_schema.create({ data: data, type: type });
                                    serialized_data = encrypted_data_schema.encode(encrypted_data_container).finish();
                                    return [4, datas.encrypt(Buffer.from(serialized_data))];
                                case 2:
                                    encrypted_data = _b.sent();
                                    done({
                                        encrypted_data: encrypted_data.encrypted_data,
                                        password: encrypted_data.key + "|" + encrypted_data.header
                                    });
                                    return [2];
                            }
                        });
                    }); })];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.encrypt_data = encrypt_data;
function encrypt_data_with_key(key, data, callback) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var _a, done, error, type, encrypted_data_container, serialized_data, encrypted_data;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = promised_callback_1["default"](resolve, reject, callback), done = _a.done, error = _a.error;
                                    return [4, get_data_type(data)["catch"](error)];
                                case 1:
                                    type = _b.sent();
                                    if (type !== "bytes") {
                                        if (type === "message") {
                                            data = Buffer.from(JSON.stringify(data));
                                        }
                                        else {
                                            data = Buffer.from(data.toString());
                                        }
                                    }
                                    encrypted_data_container = encrypted_data_schema.create({ data: data, type: type });
                                    serialized_data = encrypted_data_schema.encode(encrypted_data_container).finish();
                                    return [4, datas.encrypt_with_key(Buffer.from(serialized_data), key)];
                                case 2:
                                    encrypted_data = _b.sent();
                                    done({
                                        encrypted_data: encrypted_data.encrypted_data,
                                        password: encrypted_data.key + "|" + encrypted_data.header
                                    });
                                    return [2];
                            }
                        });
                    }); })];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.encrypt_data_with_key = encrypt_data_with_key;
function decrypt_data(encrypted_data, password, callback) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var _a, done, error, _b, key, header, decrypted_data, decrypted_data_container, decrypted_decoded_data;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    _a = promised_callback_1["default"](resolve, reject, callback), done = _a.done, error = _a.error;
                                    _b = password.split("|"), key = _b[0], header = _b[1];
                                    return [4, datas.decrypt(encrypted_data, key, header)];
                                case 1:
                                    decrypted_data = _c.sent();
                                    decrypted_data_container = encrypted_data_schema.decode(decrypted_data);
                                    decrypted_decoded_data = decrypted_data_container.data;
                                    if (decrypted_data_container.type !== Buffer) {
                                        switch (decrypted_data_container.type) {
                                            case "boolean":
                                                decrypted_decoded_data = (Buffer.from(decrypted_decoded_data).toString().match(/true/i) && true) || false;
                                                break;
                                            case "integer":
                                                decrypted_decoded_data = parseInt(Buffer.from(decrypted_decoded_data).toString(), 10);
                                                break;
                                            case "float":
                                                decrypted_decoded_data = parseFloat(Buffer.from(decrypted_decoded_data).toString());
                                                break;
                                            case "string":
                                                decrypted_decoded_data = Buffer.from(decrypted_decoded_data).toString();
                                                break;
                                            case "bytes":
                                                decrypted_decoded_data = Buffer.from(decrypted_decoded_data);
                                                break;
                                            case "message":
                                                decrypted_decoded_data = JSON.parse(Buffer.from(decrypted_decoded_data).toString());
                                                break;
                                            default:
                                                error({
                                                    error: "UNKNOWN_DATA_TYPE",
                                                    meta: {
                                                        type: decrypted_data_container.type,
                                                        decrypted_data: decrypted_data,
                                                        decrypted_decoded_data: decrypted_decoded_data
                                                    }
                                                });
                                                break;
                                        }
                                    }
                                    done(decrypted_decoded_data);
                                    return [2];
                            }
                        });
                    }); })];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.decrypt_data = decrypt_data;
function encrypt_stream_with_key(key, credentials_callback) {
    var session = {
        key: null,
        header: null,
        state: null
    };
    var transform = function (chunk, enc, callback) {
        return __awaiter(this, void 0, void 0, function () {
            var rev;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rev = Buffer.from("");
                        if (!chunk) return [3, 2];
                        return [4, datas.encrypt_chunk(chunk, session.state)["catch"](function (error) {
                                throw new Error(error);
                            })];
                    case 1:
                        rev = _a.sent();
                        _a.label = 2;
                    case 2:
                        this.push(rev);
                        callback();
                        return [2];
                }
            });
        });
    };
    var flush = function (next) {
        return __awaiter(this, void 0, void 0, function () {
            var rev;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, datas.encrypt_chunk(Buffer.alloc(0), session.state, true)["catch"](function (error) {
                            throw new Error(error);
                        })];
                    case 1:
                        rev = _a.sent();
                        this.push(rev);
                        return [2];
                }
            });
        });
    };
    var pipe = through2_1["default"](transform, flush);
    pipe.pause();
    datas.get_encryption_header(key, function (err, headers) {
        if (err) {
            throw new Error(err);
        }
        session = headers;
        if (typeof credentials_callback === "function") {
            credentials_callback(null, {
                key: session.key.toString("hex"),
                header: session.header.toString("hex")
            });
        }
        pipe.resume();
    });
    return pipe;
}
exports.encrypt_stream_with_key = encrypt_stream_with_key;
function decrypt_stream_with_key(key_hex, header_hex) {
    var session = {
        state: null
    };
    var transform = function (chunk, enc, callback) {
        return __awaiter(this, void 0, void 0, function () {
            var decrypted_data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        decrypted_data = Buffer.from("");
                        if (!chunk) return [3, 2];
                        return [4, datas.decrypt_chunk(chunk, session.state)["catch"](function (error) {
                                throw new Error(error);
                            })];
                    case 1:
                        decrypted_data = _a.sent();
                        _a.label = 2;
                    case 2:
                        this.push(decrypted_data);
                        callback();
                        return [2];
                }
            });
        });
    };
    var flush = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.emit("finished");
                return [2];
            });
        });
    };
    var pipe = through2_1["default"](transform, flush);
    pipe.pause();
    datas.get_decryption_header(key_hex, header_hex, function (err, headers) {
        if (err) {
            throw new Error(err);
        }
        session = headers;
        pipe.resume();
    });
    return pipe;
}
exports.decrypt_stream_with_key = decrypt_stream_with_key;
function generate_keys(seed, callback) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var _a, done, error, keypair;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = promised_callback_1["default"](resolve, reject, callback), done = _a.done, error = _a.error;
                                    return [4, keys.generate()["catch"](error)];
                                case 1:
                                    keypair = _b.sent();
                                    done(keypair);
                                    return [2];
                            }
                        });
                    }); })];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.generate_keys = generate_keys;
exports.derive_public_key = keys.derive_public_key;
exports.generate_master_key = keys.generate_master_key;
exports.derive_subkey = keys.derive_subkey;
exports.sign_data = signverify.sign_data;
exports.verify_data = signverify.verify_data;
exports.generate_random_string = random.random_string;
function get_data_type(data, callback) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var _a, done, error, type;
                        return __generator(this, function (_b) {
                            _a = promised_callback_1["default"](resolve, reject, callback), done = _a.done, error = _a.error;
                            if (!data) {
                                error("Data is either null or undefined. Can't work with that.");
                                return [2];
                            }
                            type = typeof data;
                            switch (typeof data) {
                                case "boolean":
                                    type = "bool";
                                    break;
                                case "number":
                                    type = "integer";
                                    if (Number(data) === data && data % 1 !== 0) {
                                        type = "float";
                                    }
                                    break;
                                case "string":
                                    type = "string";
                                    break;
                                case "object":
                                    if (Buffer.isBuffer(data)) {
                                        type = "bytes";
                                    }
                                    else {
                                        type = "message";
                                    }
                                    break;
                                default:
                                    break;
                            }
                            done(type);
                            return [2];
                        });
                    }); })];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.get_data_type = get_data_type;
