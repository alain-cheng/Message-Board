'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getParts = getParts;
exports.getRootPart = getRootPart;
exports.getChecksumValue = getChecksumValue;
exports.getRootPartId = getRootPartId;
exports.getCreativeWorkTypeFromMime = getCreativeWorkTypeFromMime;
exports.getEncodingTypeFromMime = getEncodingTypeFromMime;
exports.getAgent = getAgent;
exports.getAgentId = getAgentId;
exports.getObject = getObject;
exports.getObjectId = getObjectId;
exports.getTargetCollection = getTargetCollection;
exports.getTargetCollectionId = getTargetCollectionId;
exports.renderUrlTemplate = renderUrlTemplate;
exports.getUrlTemplateCtx = getUrlTemplateCtx;

var _urlTemplate = require('url-template');

var _urlTemplate2 = _interopRequireDefault(_urlTemplate);

var _ds3Mime = require('@scienceai/ds3-mime');

var _ds3Mime2 = _interopRequireDefault(_ds3Mime);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getParts(root, nodeMap) {
  if (nodeMap) {
    if ('@graph' in nodeMap) {
      nodeMap = nodeMap['@graph'].reduce(function (nodeMap, node) {
        nodeMap[node['@id']] = node;
        return nodeMap;
      }, {});
    }

    if (typeof root === 'string') {
      root = nodeMap[root];
    }
  }

  if (!root || !root.hasPart || !root.hasPart.length) {
    return [];
  }

  return root.hasPart.reduce(function (prev, curr) {
    return prev.concat(curr, getParts(curr, nodeMap));
  }, []);
}

function getRootPart(object) {
  var root = void 0;
  if (object && object.isPartOf) {
    root = object;
    while (root && root.isPartOf) {
      root = root.isPartOf;
    }
  }
  return root;
}

function getChecksumValue(object) {
  var algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'nash';

  if (!object) return;
  if (object.contentChecksum) {
    var checksums = Array.isArray(object.contentChecksum) ? object.contentChecksum : [object.contentChecksum];

    var checksum = checksums.find(function (checksum) {
      return checksum.checksumAlgorithm === algorithm && checksum.checksumValue;
    });
    if (checksum) {
      return checksum.checksumValue;
    }
  }
}

function getRootPartId(object) {
  var root = getRootPart(object);
  if (root) {
    return typeof root === 'string' ? root : root['@id'];
  }
}

function getCreativeWorkTypeFromMime() {
  var mimeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  // TODO delete it is now part of @scienceai/librarian
  var dataset = new Set(['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv', 'text/tab-separated-values', 'application/json', 'application/ld+json', 'application/x-ldjson', 'application/xml', 'application/rdf+xml', 'text/n3', 'text/turtle']);

  var scholarlyArticle = new Set([_ds3Mime2.default, 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.oasis.opendocument.text', 'application/x-latex']);

  var formula = new Set(['application/mathml-presentation+xml', 'application/mathml-content+xml', 'application/mathml+xml']);

  var languageMimeSuffixes = ['javascript', 'ecmascript', 'x-asm', 'x-c', 'x-c++', 'x-fortran', 'x-java', 'x-java-source', 'x-pascal', 'x-clojure', 'x-coffeescript', 'x-go', 'x-ocaml', 'x-scala', 'x-python', 'x-r', 'x-rust', 'x-erlang', 'x-julia', 'x-perl'];
  var softwareSourceCode = new Set(languageMimeSuffixes.map(function (l) {
    return 'text/' + l;
  }).concat(languageMimeSuffixes.map(function (l) {
    return 'application/' + l;
  })));

  mimeType = mimeType.split(';')[0].trim();
  var type = mimeType.split('/')[0];

  if (type === 'image') {
    return 'Image';
  } else if (type === 'video') {
    return 'Video';
  } else if (type === 'audio') {
    return 'Audio';
  } else if (dataset.has(mimeType)) {
    return 'Dataset';
  } else if (scholarlyArticle.has(mimeType)) {
    return 'ScholarlyArticle';
  } else if (softwareSourceCode.has(mimeType)) {
    return 'SoftwareSourceCode';
  } else if (formula.has(mimeType)) {
    return 'Formula';
  } else {
    return 'CreativeWork';
  }
}

function getEncodingTypeFromMime() {
  var mimeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  // TODO delete it is now part of @scienceai/librarian
  var rType = getCreativeWorkTypeFromMime(mimeType);
  switch (rType) {
    case 'Image':
      return 'ImageObject';
    case 'Audio':
      return 'AudioObject';
    case 'Video':
      return 'VideoObject';
    case 'Dataset':
      return 'DataDownload';
    case 'Article':
    case 'ScholarlyArticle':
      return 'DocumentObject';
    case 'SoftwareSourceCode':
      return 'SoftwareSourceCodeObject';
    case 'Formula':
      return 'FormulaObject';
    default:
      return 'MediaObject';
  }
}

function getAgent(agent) {
  var personOrOrganization = agent && (agent.agent || agent.recipient || agent.participant || agent.creator || agent.author || agent.contributor || agent.producer || agent.reviewer || agent.editor || agent.sender || agent.accountablePerson || agent.copyrightHolder || agent.director || agent.illustrator || agent.knows || agent.publishedBy || agent.reviewedBy || agent.sibling || agent.spouse || agent.translator || agent.grantee || agent.member) || agent;

  // Due to the context, personOrOrganization could be a list (for instance author could be defined as @container: @list)
  return Array.isArray(personOrOrganization) ? personOrOrganization[0] : personOrOrganization;
}

function getAgentId(agent) {
  var personOrOrganization = getAgent(agent);
  if (personOrOrganization) {
    return typeof personOrOrganization === 'string' ? personOrOrganization : personOrOrganization['@id'];
  }
}

/**
 * Given a schema.org Action, return the object upon which the
 * action is carried out.
 *
 * @param {Object} action - A schema.org Action.
 * @return {Object} - The object upon which the action is carried out.
 */
function getObject(action) {
  if (!action) return;
  if (action.object) {
    return action.object.object || action.object;
  }
}

/**
 * Given a schema.org Action, return the ID of the object upon which the
 * action is carried out.
 *
 * @param {Object} action - A schema.org Action.
 * @return {String} - The ID of the object upon which the action is carried out.
 */
function getObjectId(action) {
  var object = getObject(action);
  if (object) {
    return typeof object === 'string' ? object : object['@id'];
  }
}

function getTargetCollection(action) {
  if (!action) return;
  if (action.targetCollection) {
    return action.targetCollection.targetCollection || action.targetCollection;
  }
}

function getTargetCollectionId(action) {
  var targetCollection = getTargetCollection(action);
  if (targetCollection) {
    return typeof targetCollection === 'string' ? targetCollection : targetCollection['@id'];
  }
}

function renderUrlTemplate(action, params, target) {
  target = target || action.target;

  if (target && Array.isArray(target) && target.length === 1) {
    target = target[0];
  }

  if (!target || !target.urlTemplate) {
    return '';
  }

  return _urlTemplate2.default.parse(target.urlTemplate).expand(getUrlTemplateCtx(action, params));
}

function getUrlTemplateCtx(action, params) {
  action = action || {};
  params = params || {};
  var ctx = {};

  _traverse(action, function (key, value) {
    if (/-input$|-output$/.test(key)) {
      if ('valueName' in value && ('defaultValue' in value || value.valueName in params)) {
        ctx[value.valueName] = params[value.valueName] || value.defaultValue;
      }
    }
  }, this);

  return ctx;
}

function _traverse(obj, func, ctx) {
  for (var i in obj) {
    func.apply(ctx || this, [i, obj[i]]);
    if (obj[i] !== null && _typeof(obj[i]) == 'object') {
      _traverse(obj[i], func, ctx);
    }
  }
}